Pierce, figure 21-4., page 305

type Relation = Type × Type

subtype : Relation → (S : Type) → (T : Type) → Relation

subtype(A, S, T) =

  if (S, T) ∈ A, then
    A

  else
   let A₀ = A ∪ {(S, T)} in

   if S <: T (as scala types) then
     A₀

   else if S = Cons S₁ S₂ and T = Cons T₁ T₂ then
     let
       A₁ = subtype(A₀, S₁, T₁)
     in
       subtype(A₁, S₂, T₂)

   else if T = μX. T₁ then
     subtype(A₀, S, T₁[X ↦ T])

   else if S = μX. S₁ then
     subtype(A₀, S₁[X ↦ S], T)

   else
     fail


-- witness generates a conversion from S to T
-- target langauge is PLT2013/lecturenotes/04-f1wae

-- syntax tree of F1WAE
type F1WAE = Map[Symbol, FunDef] × Exp

-- we need 1-argument functions only
data FunDef = FunDef Symbol Exp

-- Exp should support function calls and pattern matching


type Witness = Map[(S : Type) × (T : Type), Symbol]

-- guarantees that result's key set contains (S, T)
witness : Witness → S → T → Witness × Map[Symbol, FunDef]
witness(A, S, T) =

  if A contains (S, T) then
    A

  else
    let
      f = newSymbol
      A₀ = A updated ((S, T), f)
    in

      if S <: T (as scala types) then
        fDef = FunDef 'x 'x
        (A₀, Map(f → fDef) // f compiles to identity function

      else if S = S₁ × S₂ and T = T₁ × T₂ then
        let
          (A₁, D₁) = witness(A₀, S₁, T₁)
          (A₂, D₂) = witness(A₁, S₂, T₂)
          f₁ = A₂(S₁, T₁)
          f₂ = A₂(S₂, T₂)
        in
          fDef = FunDef 'x (f₁ (fst 'x), f₂ (snd 'x))
          (A₂, D₁ ++ D₂ + (f → fDef))

      else if T = μX. T₁ then
        let
          (A₁, D) = witness(A₀, S, T₁)
          f₁ = A₁(S, T₁)
        in
          fDef = FunDef 'x (Roll $ f₁ 'x)
          (A₁, D + (f → fDef))

      else if S = μX. S₁ then
        let
          (A₁, D) = witness(A₀, S₁, T)
          f₁ = callName A₀(S₁, T)
        in
          fDef = FunDef 'x (f₁ $ unroll 'x)
          (A₁, D + (f → fDef))
