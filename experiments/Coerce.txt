Pierce, figure 21-4., page 305

type Relation = Type × Type

subtype : Relation → (S : Type) → (T : Type) → Relation

subtype(A, S, T) =

  if (S, T) ∈ A, then
    A

  else
   let A₀ = A ∪ {(S, T)} in

   if S <: T (as scala types) then
     A₀

   else if S = Cons S₁ S₂ and T = Cons T₁ T₂ then
     let
       A₁ = subtype(A₀, S₁, T₁)
     in
       subtype(A₁, S₂, T₂)

   else if T = μX. T₁ then
     subtype(A₀, S, T₁[X ↦ T])

   else if S = μX. S₁ then
     subtype(A₀, S₁[X ↦ S], T)

   else
     fail


type Witness = Map[(S : Type) × (T : Type), Box[S → T]]

-- guarantees that result's key set contains (S, T)
witness : Witness → S → T → Witness
witness(A, S, T) =

  if A contains (S, T) then
    A

  else
    let
      f = newNamedBox
      A₀ = A updated ((S, T), f)
    in

      if S <: T (as scala types) then
        setBox f id
        A₀

      else if S = Cons S₁ S₂ and T = Cons T₁ T₂ then
        let
          A₁ = witness(A₀, S₁, T₁)
          A₂ = witness(A₁, S₂, T₂)
          f₁ = openBox A₂(S₁, T₁)
          f₂ = openBox A₂(S₂, T₂)
        in
          setBox f (λ (Cons s₁ s₂) → Cons (f₁ s₁) (f₂ s₂))
          A₂

      else if T = μX. T₁ then
        let
          A₁ = witness(A₀, S, T₁)
          f₁ = openBox A₁(S, T₁)
        in
          setBox f (λ s → Roll $ f₁ s)
          A₁

      else if S = μX. S₁ then
        let
          A₁ = witness(A₀, S₁, T)
          f₁ = openBox A₀(S₁, T)
        in
          setBox f (λ s → f₁ $ unroll s)
          A₁
