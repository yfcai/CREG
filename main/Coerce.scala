/** Example of code generated by `coerce` */

import nominal.functors._
import nominal.lib._

object Coerce {
  // the binary tree datatype
  @data def Tree[A] = Fix(X => TreeT { Leaf(get = A) ; Fork(l = X, r = X) })

  // S = μX. Int + Fork(X, X)
  type S = Fix[({ type λ[+X] = TreeT[Leaf[Int], Fork[X, X]] })#λ]

  // T = μY. Any + Fork(Y, μZ. Int + Fork(Z, Z))
  type T = Fix[({ type λ[+Y] = TreeT[Leaf[Any], Fork[Y, S]] })#λ]

  object theWitness extends (S => T) {
    def apply(x: S): T = f0(x)

    // witness(S, T)
    def f0(x: S): T = f1(x.unroll)

    // witness(Int + Fork(S, S), T)
    def f1(x: S1): T = Roll[TF1](f2(x))
    type S1 = TreeT[Leaf[Int], Fork[S, S]]
    type TF1[+Y] = TreeT[Leaf[Any], Fork[Y, S]]

    // witness(Int + Fork(S, S), Any + Fork(T, S))
    def f2(x: S1): T2 = TreeT(x).map(identity, f3)
    type T2 = TreeT[Leaf[Any], Fork[T, S]]

    // witness(Fork(S, S), Fork(T, S))
    def f3(x: S3): T3 = Fork(x).map(f0, identity)
    type S3 = Fork[S, S]
    type T3 = Fork[T, S]
  }

  // moreover, S and T have the same runtime objects.
  type SF[+X] = TreeT[Leaf[Int], Fork[X, X]]
  implicit def toLeaf(x: Int): S = Roll[SF](Leaf(x))

  def run() {
    val s: S = coerce {
      Fork(Fork(1, 2), Fork(Fork(3, 4), Fork(5, 6)))
    }

    val t: T = theWitness(s)

    println(s"\nBefore:\n$s\n")
    println(s"\nAfter:\n$t\n")

    assert(s == t)
  }
}
