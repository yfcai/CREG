/** Example of code generated by `coerce` */

import nominal.functors._
import nominal.lib._

object Coerce {
  // the binary tree datatype
  @data def Tree[A] = Fix(X => TreeT { Leaf(get = A) ; Fork(_1 = X, _2 = X) })

  // S = μX. Int + Fork(X, X)
  type S = Fix[SF.Map]
  @functor def SF[X] = TreeT { Leaf(get = Int) ; Fork(_1 = X, _2 = X) }

  // T = μY. Any + Fork(Y, μZ. Int + Fork(Z, Z))
  type T = Fix[TF.Map]
  @functor def TF[Y] = TreeT { Leaf(get = Any) ; Fork(_1 = Y, _2 = S) }

  val theWitness = new (S => T) {
    def apply(x: S): T = f0(x)

    // witness(S, T)
    private[this] def f0(x: S): T = f1(x.unroll)

    // witness(Int + Fork(S, S), T)
    private[this] def f1(x: S1): T = Roll[TF.Map](f2(x))
    private[this] type S1 = SF.Map[S]

    // witness(Int + Fork(S, S), Any + Fork(T, S))
    private[this] def f2(x: S1): T2 = TreeT(x).map(identity, f3)
    private[this] type T2 = TF.Map[T]

    // witness(Fork(S, S), Fork(T, S))
    private[this] def f3(x: S3): T3 = Fork(x).map(f0, identity)
    private[this] type S3 = Fork[S, S]
    private[this] type T3 = Fork[T, S]
  }

  // moreover, S and T have the same runtime objects.
  implicit def toLeaf(x: Int): S = Roll[SF.Map](Leaf(x))

  def run() {
    val s: S = coerce {
      Fork(Fork(1, 2), Fork(Fork(3, 4), Fork(5, 6)))
    }

    val t: T = theWitness(s)

    println(s"\nBefore:\n$s\n")
    println(s"\nAfter:\n$t\n")

    assert(s == t)
  }
}
